/**
 * JavaCC template file created by SF JavaCC plugin 1.5.28+ wizard for JavaCC 1.5.0+
 */options{  static = false;}PARSER_BEGIN(WallsSrvFileParser)package org.andork.breakout.wallsimport;import static org.andork.breakout.wallsimport.CardinalDirection.*;import java.util.*;import java.nio.file.*;import java.nio.channels.*;import org.andork.breakout.table.SurveyModel;import org.andork.i18n.I18n.*;import org.andork.q2.*;import org.andork.swing.async.Subtask;import java.io.*;import org.andork.unit.*;import org.andork.breakout.wallsimport.WallsImportStatusMessage.Severity;public class WallsSrvFileParser{  WallsState state;  int currentLine;  int blockCommentLevel;  private String requireNoDuplicateLetters(String lcLetters)  {    BitSet b = new BitSet(26);    for (int i = 0; i < lcLetters.length(); i++)    {      int index = lcLetters.charAt(i) - 'a';      if (b.get(index))      {        throw new IllegalArgumentException("string has duplicate letters");      }      b.set(index);    }    return lcLetters;  }  private CardinalDirection parseCardinalDirection(Token token)  {    switch (token.image.charAt(0))    {      case 'n' : case 'N' : return CardinalDirection.NORTH;      case 's' : case 'S' : return CardinalDirection.SOUTH;      case 'e' : case 'E' : return CardinalDirection.EAST;      case 'w' : case 'W' : return CardinalDirection.WEST;      default : throw new IllegalArgumentException("token must be a cardinal direction");    }  }}PARSER_END(WallsSrvFileParser)TOKEN :{  < EOL :    "\n"  | "\r"  | "\r\n" >| < COMMA : "," >| < COLON : ":" >| < FSLASH : "/" >| < PLUS : "+" >| < MINUS : "-" >| < SEMICOLON : ";" >| < WHITESPACE : ([ " ", "\t", "\n", "\r" ])+ >| < NONWHITESPACE : (~[ " ", "\t", "\n", "\r" ])+ >| < END_COMMENT : < SEMICOLON > (~[ ])* >}// DirectivesTOKEN [ IGNORE_CASE ] :{  < DUNITS : "#units" >| < DSEGMENT :    "#segment"  | "#seg"  | "#s" >| < DFIX : "#fix" >| < DFLAG : "#flag" >| < DNOTE : "#note" >| < DPREFIX1 :    "#prefix"  | "#prefix1" >| < DPREFIX2 : "#prefix2" >| < DDATE : "#date" >| < DOPEN_BLOCK_COMMENT : "#[" >| < DCLOSE_BLOCK_COMMENT : "#]" >}TOKEN [ IGNORE_CASE ] :{  < DEGREES :    "degrees"  | < D >>| < MILS :    "mils"  | < M >>| < GRADS :    "grads"  | < G >>| < PERCENT :    "percent"  | < P >>| < METERS :    "meters"  | < M >>| < FEET :    "feet"  | < F >>}TOKEN [ IGNORE_CASE ] :{  < N : "n" >| < S : "s" >| < E : "e" >| < W : "w" >| < D : "d" >| < P : "p" >| < G : "g" >| < M : "m" >| < F : "f" >| < L : "l" >| < R : "r" >| < U : "u" >| < A : "a" >| < V : "v" >| < T : "t" >| < O : "o" >| < C : "c" >| < X : "x" >| < CARDINAL_DIRECTION :    < N >  | < S >  | < E >  | < W >>}// Units Options
TOKEN [ IGNORE_CASE ] :{  < SAVE : "save" >| < RESTORE : "restore" >| < RESET : "reset" >| < EQUALS : "=" >| < ORDER :    "order"  | < O >>| < DAV_ORDER :    (      < D >    | < A >    | < V >    )    {      2, 3    }    >| < ENU_ORDER :    (      < E >    | < N >    | < U >    )    {      2, 3    }    >| < AB : "ab" >| < VB : "vb" >| < DECL : "decl" >| < GRID : "grid" >| < RECT : "rect" >| < INCD : "incd" >| < INCA : "inca" >| < INCAB : "incab" >| < INCV : "incv" >| < INCVB : "incvb" >| < INCS : "incs" >| < INCH : "inch" >| < TYPEAB : "typeab" >| < TYPEVB : "typevb" >| < CORRECTED :    "corrected"  | < C >>| < NORMAL :    "normal"  | < N >>| < CASE : "case" >| < UPPER :    "upper"  | < U >>| < LOWER :    "lower"  | < L >>| < MIXED :    "mixed"  | < M >>| < LRUD : "lrud" >| < LRUD_ORDER :    (      < L >    | < R >    | < U >    | < D >    )    {      4    }    >| < FROM :    "from"  | < F >>| < TO :    "to"  | < T >>| < FROM_BISECTOR : "fb" >| < TO_BISECTOR : "tb" >| < PREFIX :    "prefix"  | < P >>| < TAPE : "tape" >| < INSTRUMENT_TO_TARGET : "it" >| < STATION_TO_STATION : "ss" >| < INSTRUMENT_TO_STATION : "is" >| < STATION_TO_TARGET : "st" >| < UVH : "uvh" >| < UVV : "uvv" >| < UV : "uv" >| < FLAG : "flag" >}TOKEN :{  < UNSIGNED_FLOATING_POINT :    < UNSIGNED_INTEGRAL >  | < UNSIGNED_INTEGRAL > "." < UNSIGNED_INTEGRAL >  | < UNSIGNED_INTEGRAL > "."  | "." < UNSIGNED_INTEGRAL >>| < UNSIGNED_INTEGRAL : (< DIGIT >)+ >| < SIGNED_INTEGRAL :    (      < MINUS >    | < PLUS >    )?    < UNSIGNED_INTEGRAL >>| < SIGNED_FLOATING_POINT :    (      < MINUS >    | < PLUS >    )?    < UNSIGNED_FLOATING_POINT >>| < #DIGIT : [ "0"-"9" ] >}private void SrvFile() :{}{  (    Line()  )*}private void Line() :{}{  < WHITESPACE >  (    UnitsLine()  | CommentLine()  )  < EOL >}
private void UnitsLine() :{}{  < DUNITS >  (    < WHITESPACE > UnitsOption()  )*  (< END_COMMENT >)?}private void CommentLine() :{}{  < END_COMMENT >}private void UnitsOption() :{}{  LengthUnitOption()| D_Option()| S_Option()| A_AB_Option()| V_VB_Option()| OrderOption()| INCA_AB_Option()| DECL_Option()| GRID_Option()| RECT_Option()}private void DECL_Option() :{  UnitizedDouble < Angle > angle;}{  < DECL > < EQUALS > angle = AzimuthNonQuadrant()  {    state.units.decl = angle;  }}private void GRID_Option() :{  UnitizedDouble < Angle > angle;}{  < GRID > < EQUALS > angle = AzimuthNonQuadrant()  {    state.units.grid = angle;  }}private void RECT_Option() :{  UnitizedDouble < Angle > angle;}{  < RECT > < EQUALS > angle = AzimuthNonQuadrant()  {    state.units.rect = angle;  }}private void OrderOption() :{  String order;}{  < ORDER > < EQUALS > order = Order()  {    state.units.order = order;  }}private void LengthUnitOption() :{  Unit < Length > lengthUnit;}{  lengthUnit = LengthUnit()  {    state.units.d_unit = state.units.s_unit = lengthUnit;  }}private void D_Option() :{  Unit < Length > lengthUnit;}{  < D > < EQUALS > lengthUnit = LengthUnit()  {    state.units.d_unit = lengthUnit;  }}private void S_Option() :{  Unit < Length > lengthUnit;}{  < S > < EQUALS > lengthUnit = LengthUnit()  {    state.units.s_unit = lengthUnit;  }}private void INCA_AB_Option() :{  UnitizedDouble < Angle > angle;  Token abToken = null;}{  < INCA >  (    < EQUALS > angle = Azimuth()  | < FSLASH > abToken = < AB > < EQUALS > angle = Azimuth()  )  {    state.units.inca = angle;    if (abToken != null)    {      state.units.incab = angle;    }  }| < INCAB > < EQUALS > angle = Azimuth()  {    state.units.incab = angle;  }}private void A_AB_Option() :{  Unit < Angle > unit;  Token abToken = null;}{  < A >  (    < EQUALS > unit = AzimuthUnit()  | < FSLASH > abToken = < AB > < EQUALS > unit = AzimuthUnit()  )  {    state.units.a_unit = unit;    if (abToken != null)    {      state.units.ab_unit = unit;    }  }| < AB > < EQUALS > unit = AzimuthUnit()  {    state.units.ab_unit = unit;  }}private void V_VB_Option() :{  Unit < Angle > unit;  Token vbToken = null;}{  < V >  (    < EQUALS > unit = InclinationUnit()  | < FSLASH > vbToken = < VB > < EQUALS > unit = InclinationUnit()  )  {    state.units.v_unit = unit;    if (vbToken != null)    {      state.units.vb_unit = unit;    }  }| < VB > < EQUALS > unit = InclinationUnit()  {    state.units.vb_unit = unit;  }}private String Order() :{  Token t;}{  t = < DAV_ORDER >| t = < ENU_ORDER >  {    return requireNoDuplicateLetters(t.image.toLowerCase());  }}private String Name() :{  Token t;}{  t = < NONWHITESPACE >  {    for (int i = 0; i < t.image.length(); i++)    {      if (!Character.isLetter(t.image.charAt(i)) && !Character.isDigit(t.image.charAt(i)))      {        state.statusMessages.add(new WallsImportStatusMessage(state.localizer.getFormattedString("invalidCharInName", t.image.charAt(i)), Severity.FATAL, state.currentFilePath, t.beginLine, t.beginColumn));        throw new WallsImportFailedException();      }    }    return t.image;  }}private int UnsignedIntegral() :{  Token t;}{  t = < UNSIGNED_INTEGRAL >  {    return Integer.parseInt(t.image);  }}private int SignedIntegral() :{  Token t;}{  t = < SIGNED_INTEGRAL >  {    return Integer.parseInt(t.image);  }}private double UnsignedFloatingPoint() :{  Token t;}{  t = < UNSIGNED_FLOATING_POINT >  {    return Double.parseDouble(t.image);  }}private double SignedFloatingPoint() :{  Token t;}{  t = < SIGNED_FLOATING_POINT >  {    return Double.parseDouble(t.image);  }}private Unit < Length > LengthUnit() :{}{  < METERS >  {    return Length.meters;  }| < FEET >  {    return Length.feet;  }}private Unit < Angle > AzimuthUnit() :{}{  < DEGREES >  {    return Angle.degrees;  }| < GRADS >  {    return Angle.gradians;  }| < MILS >  {    return Angle.milsNATO;  }}private Unit < Angle > InclinationUnit() :{}{  < DEGREES >  {    return Angle.degrees;  }| < GRADS >  {    return Angle.gradians;  }| < MILS >  {    return Angle.milsNATO;  }| < PERCENT >  {    return Angle.percentGrade;  }}private double Minutes() :{  Token t;}{  t = < UNSIGNED_FLOATING_POINT >  {    double value = Double.parseDouble(t.image);    if (value < 0.0 || value > 60.0)    {      state.statusMessages.add(new WallsImportStatusMessage(state.localizer.getString("minutesOutOfRange"), Severity.ERROR, state.currentFilePath, t.beginLine, t.beginColumn));      throw new RuntimeException("value out of range");    }    return value;  }}private double Seconds() :{  Token t;}{  t = < UNSIGNED_FLOATING_POINT >  {    double value = Double.parseDouble(t.image);    if (value < 0.0 || value > 60.0)    {      state.statusMessages.add(new WallsImportStatusMessage(state.localizer.getString("secondsOutOfRange"), Severity.ERROR, state.currentFilePath, t.beginLine, t.beginColumn));      throw new RuntimeException("value out of range");    }    return value;  }}private UnitizedDouble < Angle > AzimuthDefaultOrDMS() :{  double value = 0.0;  Unit < Angle > unit = null;  Double degrees = 0.0;  Double minutes = 0.0;  Double seconds = 0.0;}{  value = UnsignedFloatingPoint()  (    unit = AzimuthUnitSuffix()  | < COLON > minutes = Minutes()    (      < COLON > seconds = Seconds()    )?  )?  {    if (minutes != null)    {      value += minutes / 60.0;    }    if (seconds != null)    {      value += seconds / 360.0;    }    return new UnitizedDouble < Angle > (value, unit != null ? unit : state.units.a_unit);  }}private UnitizedDouble < Angle > AzimuthDegreesOrDMS() :{  double value = 0.0;  Double minutes = 0.0;  Double seconds = 0.0;}{  value = UnsignedFloatingPoint()  (    < COLON > minutes = Minutes()    (      < COLON > seconds = Seconds()    )?  )?  {    if (minutes != null)    {      value += minutes / 60.0;    }    if (seconds != null)    {      value += seconds / 360.0;    }    return new UnitizedDouble < Angle > (value, Angle.degrees);  }}private UnitizedDouble < Angle > AzimuthMS() :{  double value = 0.0;  Double minutes = 0.0;  Double seconds = 0.0;}{  < COLON >  (    (      minutes = Minutes()      (        < COLON > seconds = Seconds()      )?    )  | < COLON > seconds = Seconds()  )  {    if (minutes != null)    {      value += minutes / 60.0;    }    if (seconds != null)    {      value += seconds / 360.0;    }    return new UnitizedDouble < Angle > (value, Angle.degrees);  }}private UnitizedDouble < Angle > AzimuthQuadrant() :{  UnitizedDouble < Angle > rotation = null;  Token fromToken = null;  Token toToken = null;  CardinalDirection from = null;  CardinalDirection to = null;}{  fromToken = < CARDINAL_DIRECTION >  (    rotation = AzimuthDegrees() toToken = < CARDINAL_DIRECTION >  )?  {    from = parseCardinalDirection(fromToken);    if (toToken == null)    {      switch (from)      {        case NORTH : return new UnitizedDouble < Angle > (0.0, Angle.degrees);        case SOUTH : return new UnitizedDouble < Angle > (90.0, Angle.degrees);        case EAST : return new UnitizedDouble < Angle > (180.0, Angle.degrees);        case WEST : return new UnitizedDouble < Angle > (270.0, Angle.degrees);      }    }    to = parseCardinalDirection(toToken);    if ((from == NORTH || from == SOUTH) == (to == NORTH || to == SOUTH))    {      state.statusMessages.add(new WallsImportStatusMessage(state.localizer.getString("invalidDirectionPair"), Severity.ERROR, state.currentFilePath, toToken.beginLine, toToken.beginColumn));      throw new RuntimeException("invalid direction pair");    }    switch (from)    {      case NORTH : return to == EAST ? rotation : new UnitizedDouble < Angle > (- rotation.doubleValue(Angle.degrees), Angle.degrees);      case SOUTH : return to == EAST ? new UnitizedDouble < Angle > (180.0 - rotation.doubleValue(Angle.degrees), Angle.degrees) : new UnitizedDouble < Angle > (180.0 + rotation.doubleValue(Angle.degrees), Angle.degrees);      case EAST : return to == NORTH ? new UnitizedDouble < Angle > (90.0 - rotation.doubleValue(Angle.degrees), Angle.degrees) : new UnitizedDouble < Angle > (90.0 + rotation.doubleValue(Angle.degrees), Angle.degrees);      case WEST : return to == NORTH ? new UnitizedDouble < Angle > (270.0 + rotation.doubleValue(Angle.degrees), Angle.degrees) : new UnitizedDouble < Angle > (270.0 - rotation.doubleValue(Angle.degrees), Angle.degrees);    }  }}private UnitizedDouble < Angle > AzimuthDegrees() :{  UnitizedDouble < Angle > azimuth = null;}{  azimuth = AzimuthDegreesOrDMS()| azimuth = AzimuthMS()  {    return azimuth;  }}private UnitizedDouble < Angle > Azimuth() :{  UnitizedDouble < Angle > azimuth = null;}{  azimuth = AzimuthDefaultOrDMS()| azimuth = AzimuthMS()| azimuth = AzimuthQuadrant()  {    return azimuth;  }}private UnitizedDouble < Angle > AzimuthNonQuadrant() :{  UnitizedDouble < Angle > azimuth = null;}{  azimuth = AzimuthDefaultOrDMS()| azimuth = AzimuthMS()  {    return azimuth;  }}private Unit < Angle > AzimuthUnitSuffix() :{}{  < D >  {    return Angle.degrees;  }  < M >  {    return Angle.milsNATO;  }  < G >  {    return Angle.gradians;  }}